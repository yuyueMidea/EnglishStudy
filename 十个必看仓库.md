# Frontend (5)
1) React: https://github.com/facebook/react
2) Next.js: https://github.com/vercel/next.js
3) TypeScript: https://github.com/microsoft/TypeScript
4) TanStack Query: https://github.com/TanStack/query
5) React Testing Library: https://github.com/testing-library/react-testing-library

# AI (5)
6) OpenAI Node SDK: https://github.com/openai/openai-node
7) OpenAI Cookbook: https://github.com/openai/openai-cookbook
8) HuggingFace Transformers: https://github.com/huggingface/transformers
9) Karpathy NN Zero-to-Hero: https://github.com/karpathy/nn-zero-to-hero
10) scikit-learn: https://github.com/scikit-learn/scikit-learn

每个仓库该看哪一部分（怎么“读 repo”才有效）

**1) facebook/react（前端底层理解：调度、渲染、并发、hooks 机制）**

你该看什么：
- README / packages/ 总体结构：React 是一堆包（react、react-dom、reconciler 等）。
- packages/react-reconciler/：想理解 Fiber、调度、更新优先级，这里最关键（建议只抓主线：render → commit → schedule）。
- packages/react-dom/：事件系统、渲染入口、与浏览器交互相关逻辑。
- packages/shared/：feature flags、共享工具（能看出“为什么要这样设计”）。

侧重点（适合 5 年经验）：把 React 当“运行时系统”理解：调度（何时做）+ reconciler（做什么）+ renderer（怎么呈现）。

**2) vercel/next.js（现代全栈前端：App Router、RSC、数据获取、构建与运行时）**

你该看什么：
- docs/（如果 repo 内有）或对应文档内容的源文件：抓 App Router、Server Components、Server Actions、Cache/Fetch 行为。
- examples/：非常重要——直接挑与你工作最像的 2–3 个例子（auth、db、edge、i18n 等）。
- 与编译/构建相关的目录（如 packages/next/ 等）：你不用全看，重点看 请求进来 → 路由匹配 → 渲染/缓存 → 响应输出 的主路径。

侧重点：“Next.js 的性能与正确性”大多来自：缓存语义 + 运行时边界（server/client）+ 构建产物。

**3) microsoft/TypeScript（类型系统能力上限：泛型、推导、边界、性能）**

你该看什么：
- src/compiler/：只抓三件事：
- parser / binder / checker（怎么把代码变成类型信息并做检查）
- lib/*.d.ts：很多 Web/DOM 类型来源、细节坑点（你写 TS 时的“为什么会这样”）。
- tests/cases/compiler/（如果你愿意深入）：看 TS 团队怎么用测试描述类型边界。

侧重点：用“阅读实现 + 写类型挑战题 + 给自己项目重构类型边界”来提升，而不是只背语法。

**4) TanStack/query（前端数据层：缓存、失效、重试、并发、乐观更新）**

你该看什么：
- packages/query-core（如果分包）：核心缓存与状态机逻辑
- 文档/示例相关目录：重点看
   - query key 设计
   - staleTime/cacheTime
   - invalidation/refetch 策略
   - optimistic update & rollback
   - pagination / infinite query

侧重点：把“接口请求”升级成“数据产品”：一致性、可预测性、可观测性。

**5) testing-library/react-testing-library（测试哲学：测试用户行为而非实现）**

你该看什么：
- README：核心原则（测试越像用户使用，越可信）。
- src/（可选）：了解封装层做了什么（帮助你写更稳的测试）。
- release notes（可选）：了解 breaking changes / peer deps。

侧重点：建立你自己的测试金字塔：关键业务流程的 E2E + 组件交互测试 + 少量单元测试。

**AI 入门（新手）5 个仓库怎么用**

**6) openai/openai-node（把 AI 接进你的 Web：流式输出、工具调用、错误处理）**

你该看什么：
- README：快速跑通请求、流式（streaming）、认证方式。
- examples/（若有）：优先看
   - streaming
   - tools/function calling（如果 SDK 支持示例）
   - embeddings（为 RAG 做准备）
   - src/resources（可选）：了解 API 结构映射（遇到复杂场景更好定位）。

侧重点：工程化：超时/重试/并发限流/日志脱敏/成本控制（别把 AI 当“普通 HTTP 接口”）。

**7) openai/openai-cookbook（最实用的“模式库”：RAG、评估、提示工程）**

你该看什么（按优先级）：
- examples/：
- Embeddings + 向量检索（RAG）
- Evaluation（评估你的提示/答案）
- Rate limits / batching / caching（工程落地必看）
- guides/（若有）：把“为什么”补齐。

侧重点：从 day1 就养成“可评估”的习惯：你做的 AI 功能必须能测、能回归。

**8) huggingface/transformers（了解主流模型生态：tokenizer、pipeline、推理/微调概念）**

你该看什么：
- README + docs 引导（先学会用 pipeline 推理）
- examples/：不要贪多，挑 1 个任务做通（文本分类或文本生成任选一）。
- src/transformers（可选）：只在你卡住/好奇机制时读。

侧重点：你要知道：tokenization、attention、checkpoint、推理 vs 训练、显存/性能基础概念。

**9) karpathy/nn-zero-to-hero（把深度学习“从原理走一遍”：反向传播→MLP→语言模型）**

你该看什么：
- 仓库里的 notebooks / 课程结构：按顺序做（micrograd → makemore → …）

侧重点：这是“理解派”的入门：你会真正搞懂梯度、损失、训练循环，不会只停留在调库。

**10) scikit-learn/scikit-learn（传统机器学习与评估：数据预处理、交叉验证、指标）**

你该看什么：
- examples/：挑 2–3 个最常见套路跑通：分类/回归/聚类 + pipeline + CV。
- sklearn/：只需要对模块有概念（metrics/model_selection/preprocessing）。

侧重点：建立“机器学习基本卫生”：数据泄漏、train/test split、指标选择、基线模型。
